// Generated by CoffeeScript 1.12.7

/* jshint node:true */


/* jshint -W097 */

(function() {
  'use strict';
  var MultipartParser, Promise, debug, debugVerbose, errors, getObjectStream, headersHelper, retsParsing, through2;

  MultipartParser = require('formidable/lib/multipart_parser').MultipartParser;

  Promise = require('bluebird');

  through2 = require('through2');

  debug = require('debug')('rets-client:multipart');

  debugVerbose = require('debug')('rets-client:multipart:verbose');

  retsParsing = require('./retsParsing');

  errors = require('./errors');

  headersHelper = require('./headers');

  getObjectStream = function(retsContext, handler) {
    return new Promise(function(resolve, reject) {
      var bodyStream, done, flush, flushed, handleEnd, handleError, headerField, headerValue, headers, interceptor, multipartBoundary, objectStream, parser, partDone, ref, ref1, streamError;
      multipartBoundary = (ref = retsContext.headerInfo.contentType.match(/boundary="[^"]+"/ig)) != null ? ref[0].slice('boundary="'.length, -1) : void 0;
      if (!multipartBoundary) {
        multipartBoundary = (ref1 = retsContext.headerInfo.contentType.match(/boundary=[^;]+/ig)) != null ? ref1[0].slice('boundary='.length) : void 0;
      }
      if (!multipartBoundary) {
        throw new errors.RetsProcessingError(retsContext, 'Could not find multipart boundary');
      }
      parser = new MultipartParser();
      objectStream = through2.obj();
      objectStream.write({
        type: 'headerInfo',
        headerInfo: retsContext.headerInfo
      });
      headerField = '';
      headerValue = '';
      headers = [];
      bodyStream = null;
      streamError = null;
      done = false;
      partDone = false;
      flushed = false;
      handleError = function(err) {
        var ref2;
        debug("handleError: " + (err.error || err));
        if (bodyStream != null) {
          bodyStream.end();
        }
        bodyStream = null;
        if (!objectStream) {
          return;
        }
        if (!err.error) {
          err = {
            type: 'error',
            error: err,
            headerInfo: (ref2 = err.headerInfo) != null ? ref2 : retsContext.headerInfo
          };
        }
        return objectStream.write(err);
      };
      handleEnd = function() {
        if (done && partDone && flushed && objectStream) {
          debug("handleEnd");
          objectStream.end();
          return objectStream = null;
        } else {
          return debug("handleEnd not ready: " + (JSON.stringify({
            done: done,
            partDone: partDone,
            flushed: flushed,
            objectStream: !!objectStream
          })));
        }
      };
      parser.onPartBegin = function() {
        var object;
        debug("onPartBegin");
        object = {
          buffer: null,
          error: null
        };
        headerField = '';
        headerValue = '';
        headers = [];
        return partDone = false;
      };
      parser.onHeaderField = function(b, start, end) {
        debugVerbose("onHeaderField: " + headerField);
        return headerField += b.toString('utf8', start, end);
      };
      parser.onHeaderValue = function(b, start, end) {
        debugVerbose("onHeaderValue: " + headerValue);
        return headerValue += b.toString('utf8', start, end);
      };
      parser.onHeaderEnd = function() {
        debug("onHeaderEnd: {" + headerField + ": " + headerValue + "}");
        headers.push(headerField);
        headers.push(headerValue);
        headerField = '';
        return headerValue = '';
      };
      parser.onHeadersEnd = function() {
        var newRetsContext;
        debug("onHeadersEnd: [" + (headers.length / 2) + " headers parsed]");
        bodyStream = through2();
        newRetsContext = {
          retsMethod: retsContext.retsMethod,
          queryOptions: retsContext.queryOptions,
          headerInfo: headersHelper.processHeaders(headers),
          parser: bodyStream
        };
        return handler(newRetsContext, false).then(function(object) {
          return objectStream != null ? objectStream.write(object) : void 0;
        })["catch"](function(err) {
          return handleError(errors.ensureRetsError(newRetsContext, err));
        }).then(function() {
          partDone = true;
          return handleEnd();
        });
      };
      parser.onPartData = function(b, start, end) {
        debugVerbose("onPartData");
        return bodyStream != null ? bodyStream.write(b.slice(start, end)) : void 0;
      };
      parser.onPartEnd = function() {
        debug("onPartEnd");
        if (bodyStream != null) {
          bodyStream.end();
        }
        return bodyStream = null;
      };
      parser.onEnd = function() {
        debug("onEnd");
        done = true;
        return handleEnd();
      };
      parser.initWithBoundary(multipartBoundary);
      retsContext.parser.on('error', function(err) {
        debug("stream error");
        return handleError(err);
      });
      interceptor = function(chunk, encoding, callback) {
        parser.write(chunk);
        return callback();
      };
      flush = function(callback) {
        var err;
        debug("stream flush");
        err = parser.end();
        if (err) {
          done = true;
          partDone = true;
          handleError(new errors.RetsProcessingError(retsContext, "Unexpected end of data: " + (errors.getErrorMessage(err))));
        }
        flushed = true;
        handleEnd();
        return callback();
      };
      retsContext.parser.pipe(through2(interceptor, flush));
      return resolve(objectStream);
    });
  };

  module.exports.getObjectStream = getObjectStream;

}).call(this);
