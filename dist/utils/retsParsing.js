// Generated by CoffeeScript 1.12.7

/* jshint node:true */


/* jshint -W097 */

(function() {
  'use strict';
  var errors, expat, getSimpleParser, getStreamParser, headersHelper, hex2a, replyCodes, through2;

  expat = require('node-expat');

  through2 = require('through2');

  errors = require('./errors');

  replyCodes = require('./replyCodes');

  hex2a = require('./hex2a');

  headersHelper = require('./headers');

  getSimpleParser = function(retsContext, errCallback, parserEncoding) {
    var result;
    if (parserEncoding == null) {
      parserEncoding = 'UTF-8';
    }
    result = {
      currElementName: null,
      parser: new expat.Parser(parserEncoding),
      finish: function() {
        return result.parser.removeAllListeners();
      },
      status: null
    };
    result.parser.once('startElement', function(name, attrs) {
      if (name !== 'RETS') {
        result.finish();
        return errCallback(new errors.RetsProcessingError(retsContext, 'Unexpected results. Please check the RETS URL.'));
      }
    });
    result.parser.on('startElement', function(name, attrs) {
      result.currElementName = name;
      if (name !== 'RETS' && name !== 'RETS-STATUS') {
        return;
      }
      result.status = {
        replyCode: attrs.ReplyCode,
        replyTag: replyCodes.tagMap[attrs.ReplyCode],
        replyText: attrs.ReplyText
      };
      if (attrs.ReplyCode !== '0' && attrs.ReplyCode !== '20208') {
        result.finish();
        return errCallback(new errors.RetsReplyError(retsContext, attrs.ReplyCode, attrs.ReplyText));
      }
    });
    result.parser.on('error', function(err) {
      result.finish();
      return errCallback(new errors.RetsProcessingError(retsContext, "XML parsing error: " + (errors.getErrorMessage(err))));
    });
    result.parser.on('end', function() {
      result.finish();
      return errCallback(new errors.RetsProcessingError(retsContext, "Unexpected end of xml stream."));
    });
    return result;
  };

  getStreamParser = function(retsContext, metadataTag, rawData, parserEncoding) {
    var columnText, columns, currElementName, dataText, delimiter, errorHandler, finish, headers, parser, processStatus, responseHandler, result, retsStream, writeOutput;
    if (parserEncoding == null) {
      parserEncoding = 'UTF-8';
    }
    if (metadataTag) {
      rawData = false;
      result = {
        rowsReceived: 0,
        entriesReceived: 0
      };
    } else {
      result = {
        rowsReceived: 0,
        maxRowsExceeded: false
      };
    }
    delimiter = '\t';
    columnText = null;
    dataText = null;
    columns = null;
    currElementName = null;
    headers = null;
    parser = new expat.Parser(parserEncoding);
    retsStream = through2.obj();
    finish = function(type, payload) {
      parser.removeAllListeners();
      parser.on('error', function() {

        /* noop */
      });
      retsStream.write({
        type: type,
        payload: payload
      });
      return retsStream.end();
    };
    errorHandler = function(err) {
      return finish('error', err);
    };
    writeOutput = function(type, payload) {
      return retsStream.write({
        type: type,
        payload: payload
      });
    };
    responseHandler = function() {
      return writeOutput('headerInfo', retsContext.headerInfo);
    };
    processStatus = function(attrs) {
      var status;
      if (attrs.ReplyCode !== '0' && attrs.ReplyCode !== '20208') {
        return errorHandler(new errors.RetsReplyError(retsContext, attrs.ReplyCode, attrs.ReplyText));
      }
      status = {
        replyCode: attrs.ReplyCode,
        replyTag: replyCodes.tagMap[attrs.ReplyCode],
        replyText: attrs.ReplyText
      };
      return writeOutput('status', status);
    };
    parser.once('startElement', function(name, attrs) {
      if (name !== 'RETS') {
        return errorHandler(new errors.RetsProcessingError(retsContext, 'Unexpected results. Please check the RETS URL.'));
      }
      processStatus(attrs);
      if (!retsStream.writable) {
        return;
      }
      return parser.on('startElement', function(name, attrs) {
        currElementName = name;
        switch (name) {
          case 'DATA':
            return dataText = '';
          case 'COLUMNS':
            return columnText = '';
          case metadataTag:
            writeOutput('metadataStart', attrs);
            return result.rowsReceived = 0;
          case 'COUNT':

            /* Ignore count write when stream ended due to NO_RECORDS_FOUND (20201) error. */
            if (!retsStream.writable && parseInt(attrs.Records) === 0) {
              return false;
            }
            return writeOutput('count', parseInt(attrs.Records));
          case 'MAXROWS':
            return result.maxRowsExceeded = true;
          case 'DELIMITER':
            delimiter = hex2a(attrs.value);
            return writeOutput('delimiter', delimiter);
          case 'RETS-STATUS':
            return processStatus(attrs);
        }
      });
    });
    parser.on('text', function(text) {
      switch (currElementName) {
        case 'DATA':
          return dataText += text;
        case 'COLUMNS':
          return columnText += text;
      }
    });
    if (rawData) {
      parser.on('endElement', function(name) {
        currElementName = null;
        switch (name) {
          case 'DATA':
            writeOutput('data', dataText);
            return result.rowsReceived++;
          case 'COLUMNS':
            return writeOutput('columns', columnText);
          case 'RETS':
            return finish('done', result);
        }
      });
    } else {
      parser.on('endElement', function(name) {
        var data, i, model;
        currElementName = null;
        switch (name) {
          case 'DATA':
            if (!columns) {
              return errorHandler(new errors.RetsProcessingError(retsContext, 'Failed to parse columns'));
            }
            data = dataText.split(delimiter);
            model = {};
            i = 1;
            while (i < columns.length - 1) {
              model[columns[i]] = data[i];
              i++;
            }
            writeOutput('data', model);
            return result.rowsReceived++;
          case 'COLUMNS':
            if (!delimiter) {
              return errorHandler(new errors.RetsProcessingError(retsContext, 'Failed to parse delimiter'));
            }
            columns = columnText.split(delimiter);
            return writeOutput('columns', columns);
          case metadataTag:
            result.entriesReceived++;
            return writeOutput('metadataEnd', result.rowsReceived);
          case 'RETS':
            if (metadataTag) {
              delete result.rowsReceived;
            }
            return finish('done', result);
        }
      });
    }
    parser.on('error', function(err) {
      return errorHandler(new errors.RetsProcessingError(retsContext, "XML parsing error: " + (errors.getErrorMessage(err))));
    });
    parser.on('end', function() {
      return errorHandler(new errors.RetsProcessingError(retsContext, "Unexpected end of xml stream."));
    });
    retsContext.parser = parser;
    retsContext.errorHandler = errorHandler;
    retsContext.responseHandler = responseHandler;
    retsContext.retsStream = retsStream;
    return retsContext;
  };

  module.exports = {
    getSimpleParser: getSimpleParser,
    getStreamParser: getStreamParser
  };

}).call(this);
