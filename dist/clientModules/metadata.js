// Generated by CoffeeScript 1.12.7

/* jshint node:true */


/* jshint -W097 */

(function() {
  'use strict';
  var Promise, _getMetadataImpl, errors, getMetadata, getSystem, replyCodes, retsHttp, retsParsing, through2,
    hasProp = {}.hasOwnProperty;

  Promise = require('bluebird');

  through2 = require('through2');

  replyCodes = require('../utils/replyCodes');

  retsHttp = require('../utils/retsHttp');

  retsParsing = require('../utils/retsParsing');

  errors = require('../utils/errors');

  _getMetadataImpl = function(retsSession, type, queryOptions, client) {
    return new Promise(function(resolve, reject) {
      var currEntry, result, retsContext;
      retsContext = retsParsing.getStreamParser({
        retsMethod: 'getMetadata',
        queryOptions: queryOptions
      }, type);
      retsHttp.streamRetsMethod(retsContext, retsSession, client);
      result = {
        results: [],
        type: type
      };
      currEntry = null;
      return retsContext.retsStream.pipe(through2.obj(function(event, encoding, callback) {
        var key, ref, ref1, value;
        switch (event.type) {
          case 'data':
            currEntry.metadata.push(event.payload);
            break;
          case 'metadataStart':
            currEntry = {
              info: event.payload,
              metadata: []
            };
            result.results.push(currEntry);
            break;
          case 'metadataEnd':
            currEntry.info.rowsReceived = event.payload;
            break;
          case 'headerInfo':
            result.headerInfo = event.payload;
            break;
          case 'status':
            ref = event.payload;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              result[key] = value;
            }
            break;
          case 'done':
            ref1 = event.payload;
            for (key in ref1) {
              if (!hasProp.call(ref1, key)) continue;
              value = ref1[key];
              result[key] = value;
            }
            resolve(result);
            break;
          case 'error':
            reject(event.payload);
        }
        return callback();
      }));
    });
  };


  /*
   * Retrieves RETS Metadata.
   *
   * @param type Metadata type (i.e METADATA-RESOURCE, METADATA-CLASS)
   * @param id Metadata id
   * @param format Data format (i.e. COMPACT, COMPACT-DECODED), defaults to 'COMPACT'
   */

  getMetadata = function(type, id, format) {
    if (format == null) {
      format = 'COMPACT';
    }
    return Promise["try"]((function(_this) {
      return function() {
        var queryOptions;
        if (!type) {
          throw new errors.RetsParamError('Metadata type is required');
        }
        if (!id) {
          throw new errors.RetsParamError('Resource type id is required (or for some types of metadata, "0" retrieves for all resource types)');
        }
        queryOptions = {
          Type: type,
          ID: id,
          Format: format
        };
        return retsHttp.callRetsMethod({
          retsMethod: 'getMetadata',
          queryOptions: queryOptions
        }, _this.retsSession, _this.client);
      };
    })(this));
  };


  /*
   * Helper that retrieves RETS system metadata
   */

  getSystem = function() {
    return this.getMetadata('METADATA-SYSTEM', '0').then(function(retsContext) {
      return new Promise(function(resolve, reject) {
        var comment, comments, gotMetaDataInfo, gotSystemInfo, result, retsParser;
        result = {};
        retsParser = retsParsing.getSimpleParser(retsContext, reject);
        gotMetaDataInfo = false;
        gotSystemInfo = false;
        comment = null;
        comments = [];
        retsParser.parser.on('startElement', function(name, attrs) {
          switch (name) {
            case 'METADATA-SYSTEM':
              gotMetaDataInfo = true;
              result.metadataVersion = attrs.Version;
              return result.metadataDate = attrs.Date;
            case 'SYSTEM':
              gotSystemInfo = true;
              result.systemId = attrs.SystemID;
              result.systemDescription = attrs.SystemDescription;
              return result.timeZoneOffset = attrs.TimeZoneOffset;
            case 'COMMENTS':
              return comment = '';
          }
        });
        retsParser.parser.on('text', function(text) {
          if (retsParser.currElementName === 'COMMENTS') {
            return comment += text;
          }
        });
        retsParser.parser.on('endElement', function(name) {
          if (name === 'COMMENTS') {
            comment = comment.trim();
            if (comment.length > 0) {
              comments.push(comment);
            }
          }
          if (name !== 'RETS') {
            return;
          }
          retsParser.finish();
          if (!gotSystemInfo || !gotMetaDataInfo) {
            return reject(new errors.RetsProcessingError(retsContext, 'Failed to parse data'));
          } else {
            if (comments.length > 0) {
              result.comments = comments;
            }
            result.headerInfo = retsContext.headerInfo;
            return resolve(result);
          }
        });
        retsParser.parser.write(retsContext.body);
        return retsParser.parser.end();
      });
    });
  };

  module.exports = function(_retsSession, _client) {
    var _getParsedAllMetadataFactory, _getParsedMetadataFactory;
    if (!_retsSession) {
      throw new errors.RetsParamError('System data not set; invoke login().');
    }
    _getParsedMetadataFactory = function(type, format) {
      if (format == null) {
        format = 'COMPACT';
      }
      return function(id, classType) {
        return Promise["try"](function() {
          var options;
          if (!id) {
            throw new errors.RetsParamError('Resource type id is required (or for some types of metadata, "0" retrieves for all resource types)');
          }
          options = {
            Type: type,
            ID: classType ? id + ":" + classType : id,
            Format: format
          };
          return _getMetadataImpl(_retsSession, type, options, _client);
        });
      };
    };
    _getParsedAllMetadataFactory = function(type, format) {
      var options;
      if (format == null) {
        format = 'COMPACT';
      }
      options = {
        Type: type,
        Id: '0',
        Format: format
      };
      return function() {
        return _getMetadataImpl(_retsSession, type, options, _client);
      };
    };
    return {
      retsSession: Promise.promisify(_retsSession),
      client: _client,
      getMetadata: getMetadata,
      getSystem: getSystem,
      getResources: _getParsedMetadataFactory('METADATA-RESOURCE').bind(null, '0'),
      getForeignKeys: _getParsedMetadataFactory('METADATA-FOREIGNKEYS'),
      getClass: _getParsedMetadataFactory('METADATA-CLASS'),
      getTable: _getParsedMetadataFactory('METADATA-TABLE'),
      getLookups: _getParsedMetadataFactory('METADATA-LOOKUP'),
      getLookupTypes: _getParsedMetadataFactory('METADATA-LOOKUP_TYPE'),
      getObject: _getParsedMetadataFactory('METADATA-OBJECT'),
      getAllForeignKeys: _getParsedAllMetadataFactory('METADATA-FOREIGNKEYS'),
      getAllClass: _getParsedAllMetadataFactory('METADATA-CLASS'),
      getAllTable: _getParsedAllMetadataFactory('METADATA-TABLE'),
      getAllLookups: _getParsedAllMetadataFactory('METADATA-LOOKUP'),
      getAllLookupTypes: _getParsedAllMetadataFactory('METADATA-LOOKUP_TYPE')
    };
  };

}).call(this);
